{"version":3,"sources":["ButtonClipboard.esm.js"],"names":["_writeText","_targetElement","_feedbackElement","__classPrivateFieldSet","this","receiver","privateMap","value","has","TypeError","set","__classPrivateFieldGet","get","ClipboardButton","HTMLButtonElement","[object Object]","super","type","writeText","dataset","text","targetElementId","targetFor","undefined","Error","targetElement","document","getElementById","feedbackElementId","feedbackFor","feedbackElement","addEventListener","_clickEvent","passive","removeEventListener","_getContent","navigator","clipboard","hidden","console","info","element","textContent","tagName","toLowerCase","content","trim","WeakMap"],"mappings":"AAAA,IAaIA,EAAYC,EAAgBC,EAb5BC,EAA0BC,MAAQA,KAAKD,wBAA2B,SAAUE,EAAUC,EAAYC,GAClG,IAAKD,EAAWE,IAAIH,GAChB,MAAM,IAAII,UAAU,kDAGxB,OADAH,EAAWI,IAAIL,EAAUE,GAClBA,GAEPI,EAA0BP,MAAQA,KAAKO,wBAA2B,SAAUN,EAAUC,GACtF,IAAKA,EAAWE,IAAIH,GAChB,MAAM,IAAII,UAAU,kDAExB,OAAOH,EAAWM,IAAIP,mBAQX,MAAMQ,UAAwBC,kBACzCC,cACIC,QACAhB,EAAWU,IAAIN,UAAM,GACrBH,EAAeS,IAAIN,KAAM,MACzBF,EAAiBQ,IAAIN,KAAM,MAC3BA,KAAKa,KAAO,SAEhBF,oBACI,MAAMG,EAAYd,KAAKe,QAAQC,KACzBC,EAAkBjB,KAAKe,QAAQG,UACrC,QAAkBC,IAAdL,QAA+CK,IAApBF,EAC3B,MAAM,IAAIG,MAAM,2DAKpB,QAHkBD,IAAdL,GACAf,EAAuBC,KAAMJ,EAAYkB,QAErBK,IAApBF,EAA+B,CAC/B,MAAMI,EAAgBC,SAASC,eAAeN,GAC9C,GAAsB,OAAlBI,EACA,MAAM,IAAID,MAAM,aAAaH,oBAEjClB,EAAuBC,KAAMH,EAAgBwB,GAEjD,MAAMG,EAAoBxB,KAAKe,QAAQU,YACvC,QAA0BN,IAAtBK,EAAiC,CACjC,MAAME,EAAkBJ,SAASC,eAAeC,GAChD,GAAwB,OAApBE,EACA,MAAM,IAAIN,MAAM,aAAaI,oBAEjCzB,EAAuBC,KAAMF,EAAkB4B,GAEnD1B,KAAK2B,iBAAiB,QAAS3B,KAAK4B,YAAa,CAAEC,SAAS,IAEhElB,uBACIX,KAAK8B,oBAAoB,QAAS9B,KAAK4B,aAK3CjB,oBACI,MAAMG,OAAyDK,IAA7CZ,EAAuBP,KAAMJ,GAA4BW,EAAuBP,KAAMJ,GAAcI,KAAK+B,YAAYxB,EAAuBP,KAAMH,UAC9JmC,UAAUC,UAAUnB,UAAUA,GACmB,OAAnDP,EAAuBP,KAAMF,GAC7BS,EAAuBP,KAAMF,GAAkBoC,QAAS,EAGxDC,QAAQC,KAAK,gCAAiCtB,GAUtDH,YAAY0B,GACR,MAAMC,EAAcD,EAAQC,YAC5B,OAAQD,EAAQE,QAAQC,eACpB,IAAK,OACL,IAAK,QACL,IAAK,SACL,IAAK,WACL,IAAK,SACD,OAAOH,EAAQlC,MACnB,IAAK,OACD,OAAOkC,EAAQI,QACnB,IAAK,MACD,OAAOH,EAEf,OAAOA,EAAYI,QAG3B9C,EAAa,IAAI+C,QAAW9C,EAAiB,IAAI8C,QAAW7C,EAAmB,IAAI6C","file":"ButtonClipboard.esm.js","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _writeText, _targetElement, _feedbackElement;\n/**\n * Clipboard write text button\n *\n * @version 1.0.0\n */\nexport default class ClipboardButton extends HTMLButtonElement {\n    constructor() {\n        super();\n        _writeText.set(this, void 0);\n        _targetElement.set(this, null);\n        _feedbackElement.set(this, null);\n        this.type = 'button';\n    }\n    connectedCallback() {\n        const writeText = this.dataset.text;\n        const targetElementId = this.dataset.targetFor;\n        if (writeText === undefined && targetElementId === undefined) {\n            throw new Error('Attribute: `data-text` or `data-target-for` is not set.');\n        }\n        if (writeText !== undefined) {\n            __classPrivateFieldSet(this, _writeText, writeText);\n        }\n        if (targetElementId !== undefined) {\n            const targetElement = document.getElementById(targetElementId);\n            if (targetElement === null) {\n                throw new Error(`Element: #${targetElementId} can not found.`);\n            }\n            __classPrivateFieldSet(this, _targetElement, targetElement);\n        }\n        const feedbackElementId = this.dataset.feedbackFor;\n        if (feedbackElementId !== undefined) {\n            const feedbackElement = document.getElementById(feedbackElementId);\n            if (feedbackElement === null) {\n                throw new Error(`Element: #${feedbackElementId} can not found.`);\n            }\n            __classPrivateFieldSet(this, _feedbackElement, feedbackElement);\n        }\n        this.addEventListener('click', this._clickEvent, { passive: true });\n    }\n    disconnectedCallback() {\n        this.removeEventListener('click', this._clickEvent);\n    }\n    /**\n     * ボタン押下時の処理\n     */\n    async _clickEvent() {\n        const writeText = __classPrivateFieldGet(this, _writeText) !== undefined ? __classPrivateFieldGet(this, _writeText) : this._getContent(__classPrivateFieldGet(this, _targetElement)); // data-text と data-target-for が両方指定されている場合は前者を優先する\n        await navigator.clipboard.writeText(writeText);\n        if (__classPrivateFieldGet(this, _feedbackElement) !== null) {\n            __classPrivateFieldGet(this, _feedbackElement).hidden = false;\n        }\n        else {\n            console.info('Clipboard write successfully.', writeText);\n        }\n    }\n    /**\n     * HTMLElement のコンテンツ (Node.textContent など) を取得する\n     *\n     * @param {HTMLElement} element - HTMLElement\n     *\n     * @returns {string} Node.textContent の値 (一部要素は `value` などの属性値)\n     */\n    _getContent(element) {\n        const textContent = element.textContent; // ノードが HTMLElement である場合、 Node.textContent の値が null になることはない（空要素は空文字列を返す）\n        switch (element.tagName.toLowerCase()) {\n            case 'data':\n            case 'input':\n            case 'select':\n            case 'textarea':\n            case 'output':\n                return element.value;\n            case 'meta':\n                return element.content;\n            case 'pre':\n                return textContent;\n        }\n        return textContent.trim();\n    }\n}\n_writeText = new WeakMap(), _targetElement = new WeakMap(), _feedbackElement = new WeakMap();\n"]}